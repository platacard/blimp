// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
internal struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// - Remark: HTTP `GET /v1/apps`.
    /// - Remark: Generated from `#/paths//v1/apps/get(apps_getCollection)`.
    internal func apps_getCollection(_ input: Operations.apps_getCollection.Input) async throws -> Operations.apps_getCollection.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apps_getCollection.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/apps",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[name]",
                    value: input.query.filter_lbrack_name_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[bundleId]",
                    value: input.query.filter_lbrack_bundleId_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[sku]",
                    value: input.query.filter_lbrack_sku_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[appStoreVersions.appStoreState]",
                    value: input.query.filter_lbrack_appStoreVersions_period_appStoreState_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[appStoreVersions.platform]",
                    value: input.query.filter_lbrack_appStoreVersions_period_platform_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[appStoreVersions.appVersionState]",
                    value: input.query.filter_lbrack_appStoreVersions_period_appVersionState_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[reviewSubmissions.state]",
                    value: input.query.filter_lbrack_reviewSubmissions_period_state_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[reviewSubmissions.platform]",
                    value: input.query.filter_lbrack_reviewSubmissions_period_platform_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[appStoreVersions]",
                    value: input.query.filter_lbrack_appStoreVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "filter[id]",
                    value: input.query.filter_lbrack_id_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "exists[gameCenterEnabledVersions]",
                    value: input.query.exists_lbrack_gameCenterEnabledVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[apps]",
                    value: input.query.fields_lbrack_apps_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appEncryptionDeclarations]",
                    value: input.query.fields_lbrack_appEncryptionDeclarations_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[ciProducts]",
                    value: input.query.fields_lbrack_ciProducts_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[betaGroups]",
                    value: input.query.fields_lbrack_betaGroups_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appStoreVersions]",
                    value: input.query.fields_lbrack_appStoreVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[preReleaseVersions]",
                    value: input.query.fields_lbrack_preReleaseVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[betaAppLocalizations]",
                    value: input.query.fields_lbrack_betaAppLocalizations_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[builds]",
                    value: input.query.fields_lbrack_builds_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[betaLicenseAgreements]",
                    value: input.query.fields_lbrack_betaLicenseAgreements_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[betaAppReviewDetails]",
                    value: input.query.fields_lbrack_betaAppReviewDetails_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appInfos]",
                    value: input.query.fields_lbrack_appInfos_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appClips]",
                    value: input.query.fields_lbrack_appClips_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[endUserLicenseAgreements]",
                    value: input.query.fields_lbrack_endUserLicenseAgreements_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[inAppPurchases]",
                    value: input.query.fields_lbrack_inAppPurchases_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[subscriptionGroups]",
                    value: input.query.fields_lbrack_subscriptionGroups_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[gameCenterEnabledVersions]",
                    value: input.query.fields_lbrack_gameCenterEnabledVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appCustomProductPages]",
                    value: input.query.fields_lbrack_appCustomProductPages_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[promotedPurchases]",
                    value: input.query.fields_lbrack_promotedPurchases_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appEvents]",
                    value: input.query.fields_lbrack_appEvents_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[reviewSubmissions]",
                    value: input.query.fields_lbrack_reviewSubmissions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[subscriptionGracePeriods]",
                    value: input.query.fields_lbrack_subscriptionGracePeriods_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[gameCenterDetails]",
                    value: input.query.fields_lbrack_gameCenterDetails_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[appStoreVersionExperiments]",
                    value: input.query.fields_lbrack_appStoreVersionExperiments_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "include",
                    value: input.query.include
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appClips]",
                    value: input.query.limit_lbrack_appClips_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appCustomProductPages]",
                    value: input.query.limit_lbrack_appCustomProductPages_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appEncryptionDeclarations]",
                    value: input.query.limit_lbrack_appEncryptionDeclarations_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appEvents]",
                    value: input.query.limit_lbrack_appEvents_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appInfos]",
                    value: input.query.limit_lbrack_appInfos_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appStoreVersionExperimentsV2]",
                    value: input.query.limit_lbrack_appStoreVersionExperimentsV2_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[appStoreVersions]",
                    value: input.query.limit_lbrack_appStoreVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[betaAppLocalizations]",
                    value: input.query.limit_lbrack_betaAppLocalizations_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[betaGroups]",
                    value: input.query.limit_lbrack_betaGroups_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[builds]",
                    value: input.query.limit_lbrack_builds_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[gameCenterEnabledVersions]",
                    value: input.query.limit_lbrack_gameCenterEnabledVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[inAppPurchases]",
                    value: input.query.limit_lbrack_inAppPurchases_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[inAppPurchasesV2]",
                    value: input.query.limit_lbrack_inAppPurchasesV2_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[preReleaseVersions]",
                    value: input.query.limit_lbrack_preReleaseVersions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[promotedPurchases]",
                    value: input.query.limit_lbrack_promotedPurchases_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[reviewSubmissions]",
                    value: input.query.limit_lbrack_reviewSubmissions_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit[subscriptionGroups]",
                    value: input.query.limit_lbrack_subscriptionGroups_rbrack_
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_getCollection.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_getCollection.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 403:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_getCollection.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(body: body))
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_getCollection.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AppsResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 429:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_getCollection.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1/apps/{id}/betaGroups`.
    /// - Remark: Generated from `#/paths//v1/apps/{id}/betaGroups/get(apps_betaGroups_getToManyRelated)`.
    internal func apps_betaGroups_getToManyRelated(_ input: Operations.apps_betaGroups_getToManyRelated.Input) async throws -> Operations.apps_betaGroups_getToManyRelated.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apps_betaGroups_getToManyRelated.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/apps/{}/betaGroups",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: false,
                    name: "fields[betaGroups]",
                    value: input.query.fields_lbrack_betaGroups_rbrack_
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_betaGroups_getToManyRelated.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_betaGroups_getToManyRelated.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 403:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_betaGroups_getToManyRelated.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_betaGroups_getToManyRelated.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_betaGroups_getToManyRelated.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BetaGroupsWithoutIncludesResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 429:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_betaGroups_getToManyRelated.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ErrorResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
